defmodule AdventOfCode.Y2022.Day09 do
  @moduledoc """
  # Day 9: Rope Bridge

  Problem Link: https://adventofcode.com/2022/day/9
  """
  use AdventOfCode.Helpers.InputReader, year: 2022, day: 9

  @doc ~S"""
  Sample data:

  ```
  ```
  """
  def run(data \\ input!(), part)

  def run(data, part) when is_binary(data), do: data |> parse() |> run(part)

  def run(data, part) when is_list(data), do: data |> solve(part)

  def parse(data) do
    data
    |> String.split("\n", trim: true)
  end

  def solve(data, 1), do: solve_1(data)
  def solve(data, 2), do: solve_2(data)

  # --- <Solution Functions> ---

  @doc """
  # Part 1

  This rope bridge creaks as you walk along it. You aren't sure how old it
  is, or whether it can even support your weight.

  It seems to support the Elves just fine, though. The bridge spans a
  gorge which was carved out by the massive river far below you.

  You step carefully; as you do, the ropes stretch and twist. You decide
  to distract yourself by modeling rope physics; maybe you can even figure
  out where *not* to step.

  Consider a rope with a knot at each end; these knots mark the *head* and
  the *tail* of the rope. If the head moves far enough away from the tail,
  the tail is pulled toward the head.

  Due to nebulous reasoning involving
  <a href="https://en.wikipedia.org/wiki/Planck_units#Planck_length"
  target="_blank">Planck lengths</a>, you should be able to model the
  positions of the knots on a two-dimensional grid. Then, by following a
  hypothetical *series of motions* (your puzzle input) for the head, you
  can determine how the tail will move.

  <span title="I'm an engineer, not a physicist!">Due to the
  aforementioned Planck lengths</span>, the rope must be quite short; in
  fact, the head (`H`) and tail (`T`) must *always be touching*
  (diagonally adjacent and even overlapping both count as touching):

      ....
      .TH.
      ....

      ....
      .H..
      ..T.
      ....

      ...
      .H. (H covers T)
      ...

  If the head is ever two steps directly up, down, left, or right from the
  tail, the tail must also move one step in that direction so it remains
  close enough:

      .....    .....    .....
      .TH.. -> .T.H. -> ..TH.
      .....    .....    .....

      ...    ...    ...
      .T.    .T.    ...
      .H. -> ... -> .T.
      ...    .H.    .H.
      ...    ...    ...

  Otherwise, if the head and tail aren't touching and aren't in the same
  row or column, the tail always moves one step diagonally to keep up:

      .....    .....    .....
      .....    ..H..    ..H..
      ..H.. -> ..... -> ..T..
      .T...    .T...    .....
      .....    .....    .....

      .....    .....    .....
      .....    .....    .....
      ..H.. -> ...H. -> ..TH.
      .T...    .T...    .....
      .....    .....    .....

  You just need to work out where the tail goes as the head follows a
  series of motions. Assume the head and the tail both start at the same
  position, overlapping.

  For example:

      R 4
      U 4
      L 3
      D 1
      R 4
      D 1
      L 5
      R 2

  This series of motions moves the head *right* four steps, then *up* four
  steps, then *left* three steps, then *down* one step, and so on. After
  each step, you'll need to update the position of the tail if the step
  means the head is no longer adjacent to the tail. Visually, these
  motions occur as follows (`s` marks the starting position as a reference
  point):

      == Initial State ==

      ......
      ......
      ......
      ......
      H.....  (H covers T, s)

      == R 4 ==

      ......
      ......
      ......
      ......
      TH....  (T covers s)

      ......
      ......
      ......
      ......
      sTH...

      ......
      ......
      ......
      ......
      s.TH..

      ......
      ......
      ......
      ......
      s..TH.

      == U 4 ==

      ......
      ......
      ......
      ....H.
      s..T..

      ......
      ......
      ....H.
      ....T.
      s.....

      ......
      ....H.
      ....T.
      ......
      s.....

      ....H.
      ....T.
      ......
      ......
      s.....

      == L 3 ==

      ...H..
      ....T.
      ......
      ......
      s.....

      ..HT..
      ......
      ......
      ......
      s.....

      .HT...
      ......
      ......
      ......
      s.....

      == D 1 ==

      ..T...
      .H....
      ......
      ......
      s.....

      == R 4 ==

      ..T...
      ..H...
      ......
      ......
      s.....

      ..T...
      ...H..
      ......
      ......
      s.....

      ......
      ...TH.
      ......
      ......
      s.....

      ......
      ....TH
      ......
      ......
      s.....

      == D 1 ==

      ......
      ....T.
      .....H
      ......
      s.....

      == L 5 ==

      ......
      ....T.
      ....H.
      ......
      s.....

      ......
      ....T.
      ...H..
      ......
      s.....

      ......
      ......
      ..HT..
      ......
      s.....

      ......
      ......
      .HT...
      ......
      s.....

      ......
      ......
      HT....
      ......
      s.....

      == R 2 ==

      ......
      ......
      .H....  (H covers T)
      ......
      s.....

      ......
      ......
      .TH...
      ......
      s.....

  After simulating the rope, you can count up all of the positions the
  *tail visited at least once*. In this diagram, `s` again marks the
  starting position (which the tail also visited) and `#` marks other
  positions the tail visited:

      ..##..
      ...##.
      .####.
      ....#.
      s###..

  So, there are *`13`* positions the tail visited at least once.

  Simulate your complete hypothetical series of motions. *How many
  positions does the tail of the rope visit at least once?*

  """
  def solve_1(data) do
    data
    |> Enum.map(&String.split/1)
    |> Enum.map(fn [dir, num] -> {dir, String.to_integer(num)} end)
    |> Enum.flat_map(fn {dir, num} -> List.duplicate(dir, num) end)
    |> Enum.reduce({{0, 0}, [{0, 0}]}, fn dir, {{xh0, yh0} = hp0, [tp0 | _] = tacc} ->
      hp1 =
        case dir do
          "U" -> {xh0, yh0 + 1}
          "D" -> {xh0, yh0 - 1}
          "L" -> {xh0 - 1, yh0}
          "R" -> {xh0 + 1, yh0}
        end

      tp1 = if touching?(tp0, hp1), do: tp0, else: hp0

      {hp1, [tp1 | tacc]}
    end)
    |> elem(1)
    |> tap(&print_board(&1, false))
    |> MapSet.new()
    |> Enum.count()
  end

  @doc """
  # Part 2
  """
  def solve_2(data) do
    {2, :not_implemented}
  end

  # --- </Solution Functions> ---

  defp touching?({x0, y0}, p1) do
    p1 in for dx <- -1..1, dy <- -1..1, do: {x0 + dx, y0 + dy}
  end

  defp print_board(_, false), do: :ok

  defp print_board(positions, _) do
    xs = positions |> Enum.map(fn {x, _} -> x end)
    ys = positions |> Enum.map(fn {_, y} -> y end)
    {xmin, xmax} = Enum.min_max(xs)
    {ymin, ymax} = Enum.min_max(ys)

    for y <- ymax..min(ymin, 0) do
      for x <- min(xmin, 0)..xmax do
        if {x, y} in positions, do: "#", else: "."
      end
      |> IO.puts()
    end
  end
end
